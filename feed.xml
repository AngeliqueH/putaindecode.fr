<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Putain de Code !</title>
        <description>On voulait mettre une baseline mais on a pas été foutu d&#x27;en trouver une</description>
        <link>/</link>
        <generator>happyplan 0.4.0-alpha.8</generator>
        <lastBuildDate>Wed, 06 November 2013 00:00:00 +0100</lastBuildDate>

          <item>
              <title>Comment contribuer ?</title>
              <description>

{{#markdown}}
Ici, chez Putain de Code, dans notre building 8 étages vitres teintées avec
masseuses et coke à volonté et à n&#x27;importe quelle heure de la journée, on sait
qu&#x27;on va forcément t&#x27;aider à comprendre pas mal de trucs, mais on sait aussi
qu&#x27;on peut faire des fois des erreurs dans les articles (à cause de la coke)
ou tout simplement qu&#x27;il existe des types encore plus hipster
qu&#x27;[\_mlb](http://putaindecode.fr/le-crew/#mlbli) et qui voudront profiter de
notre renomée inter~~nationale~~galactique pour se faire un peu de visibilité
en proposant un post. Du coup, on s&#x27;attend vraiment à ce que tu aides à faire
avancer le bouzin, que t&#x27;apportes ta pierre à l&#x27;édifice quoi (oui on t&#x27;apprend
des expressions aussi), ou ta PR au repo comme on dit dans le monde des
développeurs des internets.

## GitHub

* Déjà, si t&#x27;en as pas, crée toi un compte GitHub (avant qu&#x27;on te caillasse),
  et vu que tu commences à lire des ressources sur notre site, crois moi que
  tu vas commencer à le faire chauffer plus vite que prévu.

* Ensuite il faut que tu installes tout le nécessaire pour bosser sur un
  *repo* GitHub (oui on va commencer à utiliser des anglicismes dès maintenant
  donc habitues toi y, *repo* = dépôt de code, comme tu peux le constater, la
  francisation, c&#x27;est moche), on va te faire un post qui va regrouper tout ce
  qu&#x27;il te faut pour installer et configurer Git pour bosser sur GitHub.

* Après, il faut que tu crées ce qu&#x27;on appelle un *fork* du repo. Un fork
  c&#x27;est juste ta propre copie du repo. Bah ouais, tu vas pas directement
  travailler sur notre repo et nous le crader sans qu&#x27;on puisse bouger
  l&#x27;orteil. Non monsieur, sur GitHub on est des gens civilisés et on créé sa
  propre copie dans son coin avant de demander à papa si on a le droit
  d&#x27;apporter les modifs sur le repo principal.

* Pour ça, clique sur le bouton *Fork* en haut à droite du repo. GitHub va
  créer une copie du repo sur ton propre compte GitHub, où tu pourras
  travailler tranquillement.

  &lt;figure&gt;
    ![Bouton Fork]({{ happyplan.baseUrls.media }}/github/fork-button.jpg)
    &lt;figcaption&gt;Clique au fond à droite&lt;/figcaption&gt;
  &lt;/figure&gt;

* Maintenant que t&#x27;as enfin notre magnifique repo dans ton compte, tu devrais
  te sentir honoré. Une fois que t&#x27;as appelé toute ta famille et les 3
  pèquenauds qui te servent d&#x27;amis, tu dois pouvoir y coder dessus sur ton PC.
  On va partir du principe que tu t&#x27;appelles Clint. Et que ton nom c&#x27;est
  Horris. T&#x27;as donc choisi comme pseudo GitHub &#x60;clinthorris&#x60; (oui t&#x27;aurais du
  réfléchir toi aussi). Donc tu te débrouilles pour aller dans un dossier vide
  et tu vas cloner notre repo. Cloner = faire une copie d&#x27;un repo distant (sur
  les serveurs de GitHub par exemple) en local (ton vieux Pentium II sous XP
  dans notre cas). Ensuite il faut que tu te rendes dans ce dossier en ligne
  de commande (sous Windows tu y vas avec l&#x27;invite de commande mais on te
  prévient qu&#x27;on va pas être copains longtemps, trouve un OS décent putain,
  sous Mac OS X tu utilises le terminal, et sous Linux je pense qu&#x27;on a pas à
  t&#x27;expliquer).

  &#x60;&#x60;&#x60;
  $ git clone https://github.com/clinthorris/website.git putaindecode
  &#x60;&#x60;&#x60;

* Ensuite tu dois ajouter ce qu&#x27;on appelle une remote. Une remote c&#x27;est une
  référence du repo principal, le beau, le grand, le nôtre. En gros, ça va te
  servir que si tu fais une modification ou une contribution sur notre site
  aujourd&#x27;hui, et que dans un mois tu veuilles encore en faire, tu pourras
  facilement rattraper tout ce qu&#x27;on aura fait entre temps. La remote en
  rapport avec le repo principal, on l&#x27;appelle souvent *upstream*

    &#x60;&#x60;&#x60;
    $ cd putaindecode
    $ git remote add upstream https://github.com/putaindecode/website.git
    $ git fetch upstream
    &#x60;&#x60;&#x60;

* Alors là, normalement, t&#x27;as le dossier propre et frais, pêché du matin. Vu
  que notre site pète la classe, et qu&#x27;on l&#x27;a fait en utilisant quand même des
  technos ultra cool genre [HappyPlan](https://github.com/happyplan/happyplan)
  (un truc fait par @_kud et @MoOx, t&#x27;en profiteras pour aller jeter un oeil,
  fais pas ton rat, t&#x27;es pas pressé), node, bower, toussa, il va falloir que
  t&#x27;installes les dépendances, les requirements, et toute la ribambelle de
  fichiers qui vont bien. Pour faire ça, c&#x27;est pas compliqué, tu vas lire le
  README.md à la racine du repo. On fait exprès de pas te le dire ici parce
  que c&#x27;est un peu une convention pour tous les projets susceptibles d&#x27;être
  utilisés en Open Source, et que ça te fait pas de mal de commencer à
  apprendre à bien bosser.

* Une fois ton site tout installé, t&#x27;as plus qu&#x27;à aller dans ton dossier grâce
  à la ligne de commande, et à taper &#x60;$ happyplan&#x60;, tu verras tout un tas de
  trucs grunt s&#x27;exécuter, ne t&#x27;inquiètes pas. À la fin du processus, ça
  devrait te lancer le site en local dans le browser. Là j&#x27;espère que tu te
  rends compte qu&#x27;avec une seule ligne de commande on t&#x27;a fait tourner un site
  complet. Et là on te voit déjà en train de baver et te rappeler tes longues
  soirées en train d&#x27;installer PHP, MySQL, un WordPress, la bonne version des
  plugins, de la conf à n&#x27;en plus finir... ah qu&#x27;est-ce que tu pouvais être
  niais. Ça a quand même bien plus la classe notre solution, non ?

* Maintenant que t&#x27;as tout, t&#x27;as plus qu&#x27;à lancer ~~notepad++~~ ton éditeur
  favori et te préparer à modifier ou proposer les fichiers que tu veux. Ce
  que t&#x27;as à retenir, c&#x27;est que tu vas surtout bosser dans le dossier &#x60;/src&#x60;

## Correction d&#x27;un post existant

Bon ok, on a compris, t&#x27;es timide, tu te sens pas encore prêt à nous écrire un
magnifique post sur ton tout dernier projet, tu préfères juste nous aider à
améliorer notre contenu. Bah on te remercie quand même tu vois, parce qu&#x27;on
est des types sympas.

* Alors déjà, on aime pas juste donner une liste d&#x27;ordres sans expliquer pour
  que tu puisses comprendre ce que tu fais. Donc notre site, il a été fait
  grâce à HappyPlan (un générateur de site statique bien pimpé, parce que oui,
  y&#x27;a pas que Wordpress pour faire un site) qui lui même est basé sur grunt
  (un esclave qui te permet d&#x27;éxécuter des tâches répétitives en JavaScript)
  et plein d&#x27;autres truc cools. Donc, faudrait que tu jettes un coup d&#x27;œil à
  ces projets, histoire de savoir de quoi on cause, même si on va essayer de
  t&#x27;expliquer au mieux.

* Donc, tous nos posts sont contenus dans &#x60;src/posts/&#x60;. Si jamais c&#x27;est sur
  autre chose qu&#x27;un post, farfouille un peu et tu trouveras, le nom des
  dossiers est assez explicite et de toute façon les URLs sur notre site
  ressemblent bizarrement (en vrai c&#x27;est pas bizarre hein, t&#x27;avais compris)
  aux noms des dossiers.

* Donc, une fois le fichier trouvé, tu remarqueras que la syntaxe à
  l&#x27;intérieur, c&#x27;est pas du HTML. C&#x27;est un truc bizzare avec des dièses et des
  étoiles. On appelle ça du
  [*Markdown*](http://fr.wikipedia.org/wiki/Markdown). On va te laisser aller
  chercher si tu veux connaitre plus en détail. Mais normalement en voyant le
  reste du post autour de toi, tu devrais comprendre assez vite. Tu peux
  toujours faire du HTML, mais franchement, le Markdown a été créé pour ce
  genre de tâches, c&#x27;est un bon moment pour l&#x27;apprendre.

* Avant de faire les modifications direct dans le fichier, on va te demander
  de faire une branche, c&#x27;est une bonne pratique et ça nous permettra de voir
  exactement ce que t&#x27;auras modifié, c&#x27;est beaucoup plus simple. Du coup tu
  fais simplement un :

  &#x60;&#x60;&#x60;
  $ git checkout -b fix.nom-du-post
  &#x60;&#x60;&#x60;

* Fais les modifications que tu veux dans le fichier, là on peut pas t&#x27;aider,
  c&#x27;est à toi de jouer.

* Normalement si t&#x27;avais bien lancé le &#x60;happyplan&#x60; tout à l&#x27;heure, y&#x27;a un
  processus *watch* (en gros un truc qui surveilles ton projet) qui est lancé
  et qui détecte que t&#x27;as changé un fichier, du coup, grâce au watch couplé à
  un processus appelé *livereload* ton navigateur va rafraichir les fichiers
  nécessaires en direct. T&#x27;as rien à faire c&#x27;est magique. Enfin si tu juste
  retourner dans ton browser ça devrait déjà être à jour.

* Une fois que tout est bon, tu peux passer à l&#x27;étape de validation de tes
  modifications (étape commune pour la modification d&#x27;un post existant ou la
  proposition d&#x27;un nouveau)

## Proposition d&#x27;un nouveau post

* Alors pour proposer un nouveau post déjà, il te faut une idée. Et on te
  prévient que si tu nous sort un post sur la liste des plugins jQuery les
  plus en vogue cette semaine, on va te trouver. On va chercher ton IP, on va
  tracer ton adresse, et on va te trouver. Et tu vas comprendre que parmi
  nous, y&#x27;a des types qui sont pas du tout copains avec jQuery et qui sont pas
  tendres du tout.

* Il faut aussi que tu fasses attention à ne pas bosser sur le même post que
  quelqu&#x27;un d&#x27;autre et pour ça tu dois aller jeter un coup d&#x27;oeil du côté des
  issues en cours avec le label &#x60;post&#x60;. Allez, on est sympa, t&#x27;as [le
  lien](https://github.com/putaindecode/website/issues?labels=post&amp;page=1&amp;state=open).

* Bref, une fois ton idée trouvée, il faut que tu crées le post pour pouvoir
  commencer à écrire dans le fichier. Tout d&#x27;abord tu vas devoir créer une
  nouvelle branche. C&#x27;est une pratique qu&#x27;on demande à tout le monde, même
  nous en interne on bosse sur des branches. Donc tout d&#x27;abord :

  &#x60;&#x60;&#x60;
  $ git checkout -b post.titre-court-du-post
  &#x60;&#x60;&#x60;

  Ensuite il va falloir que tu crées le fichier nécessaire pour le brouillon
  du post.

  &#x60;&#x60;&#x60;
  $ happyplan newpost --name=&quot;Nom du post&quot; --tags=&quot;tags, separes, virgules&quot;
  $ mkdir src/posts/nom-du-post
  $ mv src/posts/nom-du-post.html.hbs src/posts/nom-du-post/index.html.hbs
  &#x60;&#x60;&#x60;

  Ça va te créer un fichier dans &#x60;/src/posts/&#x60; avec le nom qui va bien.
  Tu remarqueras qu&#x27;on la déplacé dans un dossier, histoire d&#x27;avoir des URLs
  simples et sympa. Puis si t&#x27;as de la merde à fourrer pour ton article, tu sais
  où la mettre du coup.

* Tu peux maintenant éditer ton fichier en MarkDown dans la partie dédié,
  tout en faisant attention si tu te mets à toucher l&#x27;entête créé
  automatiquement (celui où il y a layout, title et tags).
  Laisse bien la clé &#x60;draft: true&#x60; bien entendu.
  Amuse toi, créé ton contenu, rédige bien tout comme tu veux.
  Techniquement, dans ce dossier &#x60;posts&#x60; tu peux faire autant de brouillons
  que tu veux pour peut que tu spécifies bien une clé &#x60;draft&#x60; pour chaque post.

* Tu devrais pouvoir te balader sur le site est trouver ton article sur la page
  des brouillons: http://localhost:4242/posts/drafts.html .
  Avec la tâche &#x60;$ happyplan&#x60; lancée normalement tout se rafraichira
  automatiquement.
  Si ce n&#x27;est pas le cas, lance la tâche &#x60;$ happyplan&#x60;.
  Si là tu as une erreur qui t&#x27;échappes, on t&#x27;invite à
  [ouvrir une issue](https://github.com/putaindecode/website/issues/new).

* En l&#x27;état tu devrais pouvoir consulter sur le site lancé localement ton post,
  voir s&#x27;il sort correctement et s&#x27;il est présentable à ton goût.
  Tu pourras le consulter sur une URL du type
  &#x60;http://localhost:4242/post/nom-du-post/&#x60;. Mais tu le sais déjà puisque t&#x27;as
  bien suivi et que t&#x27;es passé par la page des brouillons.

* Une fois que tout est bon, tu peux passer à l&#x27;étape de validation de tes
  modifications (étape commune pour la modification d&#x27;un post existant ou la
  proposition d&#x27;un nouveau)

## Validation de tes modifications

* Il faut tout d&#x27;abord pousser tes modifications sur ton &#x60;fork&#x60;. Pour ça on va
  d&#x27;abord ajouter les fichier que tu as modifié à l&#x27;index de fichiers à
  commit. Tu peux faire ça tout simplement avec un :

  &#x60;&#x60;&#x60;
  $ git add -A src/posts/nom-du-post
  &#x60;&#x60;&#x60;

  Cette commande ajoute tous les fichiers dans le dossier que tu as créé.
  Si tu as ajouter des fichiers à l&#x27;exterieur de ce dossier, tu devras les
  ajouter. Exemple:

  &#x60;&#x60;&#x60;
  $ git add src/media/memes/trollface.jpg
  &#x60;&#x60;&#x60;

  Ensuite on va dire à git de valider ces modifications de code :

  &#x60;&#x60;&#x60;
  $ git commit -m &quot;Un petit message sympa expliquant le correctif/post&quot;
  &#x60;&#x60;&#x60;

  Et on va finir en disant qu&#x27;on veut envoyer tout ça sur ton fork qui est
  situé sur GitHub :

  &#x60;&#x60;&#x60;
  $ git push -u
  &#x60;&#x60;&#x60;

* Voila ! Si tu vas voir ton &#x60;fork&#x60; sur GitHub tu verras ton commit et les
  modifications que tu as apportées normalement. Il ne te reste plus qu&#x27;à nous
  soumettre ces modifications. Pour ça tu vas faire ce qu&#x27;on appelle une Pull
  Request (PR)

* Il te suffit de cliquer sur le bouton vert qui représente 2 flèches en sens
  inverse à côté du nom de ta branche en dessous du nombre de commits /
  branches / etc.

  &lt;figure&gt;
    ![Bouton Pull Request]({{ happyplan.baseUrls.media }}/github/pull-request-button.jpg)
    &lt;figcaption&gt;C&#x27;est bon tu le vois là le bouton ?&lt;/figcaption&gt;
  &lt;/figure&gt;

* Sélectionnes les bonnes branches et ajoute nous un beau titre et une belle
  description de Pull Request en essayant au moins de commencer par &#x60;Post:
  Nom du post&#x60; ou &#x60;Fix: Nom du post

* Et voila ! Tu n&#x27;as qu&#x27;à attendre de nos nouvelles maintenant. D&#x27;ailleurs au
  passage, si tu veux, tu peux en profiter pour nous suivre [sur
  twitter](http://twitter.com/putaindecode), et tu pourras nous lâcher un
  message avec ta PR ou ton issue en lien, histoire de nous mettre la pression.
  
## Hey ! Tu veux mieux comprendre Git ?

Pour découvrir Git plus en détails, on t&#x27;invite à lire notre article
[Versionner avec Git](posts/git/versionner-avec-git/)
{{/markdown}}
</description>
              <pubDate>Tue, 05 November 2013 01:00:00 +0100</pubDate>
              <link>/dist/posts/comment-contribuer/index.html</link>
              <guid isPermaLink="true">/dist/posts/comment-contribuer/index.html</guid>
          </item>

          <item>
              <title>Versionner avec Git</title>
              <description>

{{#markdown}}
Chez Putain de Code, on aime se servir de [Git][git:website] (et de GitHub, mais
c&#x27;est une autre histoire), même si certains d&#x27;entre nous (comme Lionel) ne s&#x27;en
servent pas forcément bien.

Pour éviter ce genre de mésaventures, on s&#x27;est dit qu&#x27;on allait consacrer une
série d&#x27;articles à ce merveilleux gestionnaire de versions, et de vous en faire
profiter par la même occasion.

Et si Git permet de faire à peu près ce qu&#x27;on veut sur un dépôt, vous verrez
qu&#x27;on peut assez facilement réparer ses erreurs (et même celles des autres
parfois !).


## C&#x27;est quoi Git ?

Si vous êtes un développeur un tant soit peu consciencieux, vous utilisez un
gestionnaire de versions pour suivre l&#x27;évolution de votre code. Non,
[CPOLD][cpold] n&#x27;est pas un gestionnaire de versions.

Git, c&#x27;est un gestionnaire de versions décentralisé, aussi connu sous le terme
de DVCS (pour Distributed Version Control System) pour les amateurs.

Le terme *distribué* est très important car c&#x27;est ce qui le différencie d&#x27;autres
gestionnaires historiquement plus connus comme Subversion (SVN) ou le vénérable
CVS.

Ça veut dire que chaque développeur possède sa propre copie du dépôt, chez lui,
localement, contraîrement à un gestionnaire centralisé ou tout est… centralisé
sur un même serveur (merci Captain Obvious).

Git est principalement utilisable en ligne de commande, mais il existe des
interfaces graphiques sous les principaux OS du marché (OS X, Linux, Windows).
Ici on va traiter de la ligne de commande, car c&#x27;est l&#x27;arme de base du bon
développeur.

Je vous passe l&#x27;installation, référez-vous à la documentation officielle pour
cette partie. (Ça se résume souvent à un &#x60;nom-du-package-manager install git&#x60;)

## Comment ça marche ?

Avant d&#x27;attaquer la partie pratique, on va s&#x27;attarder un peu à comment Git
fonctionne, parce qu&#x27;à mon sens c&#x27;est essentiel pour comprendre rapidement ce
qu&#x27;il est possible de faire et pour se construire un modèle mental des
opérations.

Dans Git les commits sont tous reliés avec leur(s) parent(s) comme les maillons
d&#x27;une chaîne qui pourrait avoir des bifurcations. Chaque commit stocke des
informations sur l&#x27;état du dépôt à un instant donné (l&#x27;état complet, pas
uniquement un diff).

On construit cette chaîne et ses bifurcations en créant des commits, en
branchant et en fusionant une branche dans une autre.

Enfin, une dernière chose que vous devez garder en tête c&#x27;est qu&#x27;un commit est
définitif dans le sens ou on ne pourra jamais modifier son contenu (on pourra
par contre le remplacer par un autre). Comme il est unique, il a un numéro qui
est un haché &#x60;SHA1&#x60; de diverses informations.

Ces &#x60;SHA1&#x60; sont utilisé à foison, habituez-y vous !

Voilà, maintenant sortons nous les doigts et regardons comment ça marche
concrètement.

## Créer ou récupérer un repo

Il y a deux manières de créer un dépôt Git : soit on en veut un tout neuf et on
utilise &#x60;git init&#x60;, soit on veut cloner un dépôt déjà existant et on utilise le
bien nommé &#x60;git clone&#x60;.

Appellé sans argument, &#x60;git init&#x60; initialise un dépôt dans le dossier courant,
on peut lui passer un nom de dépôt en argument pour le créer dans un
sous-dossier spécifique du dossier courant.

Du côté de &#x60;git clone&#x60;, on va passer l&#x27;adresse d&#x27;un dépôt, et optionnellement un
nom local pour le dépôt. Il va récupérer le dépôt à l&#x27;adresse spécifiée (c&#x27;est
bien foutu hein ?) puis le mettre soit dans un dossier du même nom soit dans un
dossier du nom spécifié en dernier argument.

Par exemple, si je veux cloner le dépôt du site :

&#x60;&#x60;&#x60; console
$ git clone https://github.com/putaindecode/website.git
&#x60;&#x60;&#x60;

Ça va créer un dossier &#x60;website&#x60; avec le contenu du dépôt.

&#x60;clone&#x60; accepte plusieurs types d&#x27;adresse : HTTP(S), SSH, protocole Git dédié et
même des chemins locaux pour cloner un dépôt situé ailleurs sur le système de
fichiers.

Pour la suite, il va falloir se placer dans un dépôt avec le petit &#x60;cd&#x60; qui va
bien pour lancer les vraies commandes intéressantes de Git.

## Premiers commits

Pour commencer à s&#x27;amuser, écrivez un bout de code dans un fichier et
sauvegardez le :

&#x60;&#x60;&#x60; console
$ cat &gt; putain_de_hello_world.rb
puts &quot;Hello, putain de codeur !&quot;
^D
&#x60;&#x60;&#x60;

On va tout se suite introduire l&#x27;un des concepts déroutants de Git, *l&#x27;Index*.
Git utilise trois zones distinctes pour les fichiers : le dossier de travail
(*Working Dir*) qui contient les fichiers dans leur version actuelle, *l&#x27;Index*
qui permet de stocker les modifications et &#x60;HEAD&#x60; qui pointe vers le dernier
commit.

L&#x27;idée, c&#x27;est qu&#x27;on peut modifier les fichiers comme on le souhaite, et
constuire le commit avec seulement les modifications que l&#x27;on souhaite voir
apparaître.

Cette possibilité permet d&#x27;avoir des commits atomiques, c&#x27;est à dire qui
introduisent une modification simple. Ça évite de se retrouver avec un commit
mammouth qui change tout le programme d&#x27;un coup et qui est un enfer pour le
futur développeur qui revient sur le code et qui cherche à comprendre la logique
de sa construction. Ce développeur, c&#x27;est vous dans 1 ou 2 semaines.

Pour info, vous verrez parfois *l&#x27;Index* appellé *Staging Area*.

Git fournit des commandes pour passer les fichiers d&#x27;un état à l&#x27;autre. Elles
sont certes parfois un peu obscures, mais dans l&#x27;ensemble c&#x27;est pas si
difficile.

Dans notre cas, notre fichier n&#x27;est même pas encore suivi par Git ! Vous pouvez
vérifier ça en utilisant &#x60;git status&#x60;,dont vous ne pourrez bientôt plus vous
passer :

Pour pallier celà, on utilise &#x60;git add&#x60; pour l&#x27;ajouter direct à l&#x27;index.

Dans notre cas, ça donne &#x60;git add putain_de_hello_world.rb&#x60;

On peut utilise &#x60;git add&#x60; pour ajouter des dossiers entiers, des motifs, … Mais
soyez vigilants, c&#x27;est une bonne source d&#x27;erreurs souvent chiantes.

&#x60;&#x60;&#x60; console
# Sur la branche master
#
# Validation initiale.
#
# Fichiers non suivis:
#   (utilisez &quot;git add &lt;fichier&gt;...&quot; pour inclure dans ce qui sera validé)
#
#	putain_de_hello_world.rb
Aucune modification indexée mais des fichiers non suivis sont présents (utilisez &quot;git add&quot; pour les suivre)
&#x60;&#x60;&#x60;

Vous pouvez vérifier que &#x60;git add&#x60; a bien marché avec la commande &#x60;git status&#x60;,

&#x60;&#x60;&#x60; console
$ git status
# Sur la branche master
#
# Validation initiale.
#
# Modifications qui seront validées :
#   (utilisez &quot;git rm --cached &lt;fichier&gt;...&quot; pour désindexer)
#
#	nouveau : putain_de_hello_world.rb
#
&#x60;&#x60;&#x60;

Ok c&#x27;est prêt ! On lance maintenant &#x60;git commit&#x60; pour créer notre premier commit
(pas con le *naming* de la commande hein ?). Si tout se passe bien vous devriez
avoir un éditeur qui s&#x27;ouvre pour écrire un message de commit. Prenez l&#x27;habitude
de décrire votre changement sur la première ligne succintement et, si vous avez
besoin de détails, sautez une ligne et détaillez les modifications.

Un petit &#x60;git status&#x60; nous confirme qu&#x27;on s&#x27;est pas foiré (la preuve, tout est
propre) :

&#x60;&#x60;&#x60; console
$ git status
# Sur la branche master
rien à valider, la copie de travail est propre
&#x60;&#x60;&#x60;

## Inspecter

Bon, c&#x27;est bien beau de commiter, mais à un moment on arrive sur un projet en
cours et on aimerait bien savoir où on en est. Pour ça vous pouvez utiliser un
outil graphique (il y en a pour [Linux][gitg], [OS X][gitx] et même sûrement
Windows) ou retrousser vos poils de barbe et sortir le bon vieux &#x60;git log&#x60;.

C&#x27;est un vrai couteau-suisse qui va vous permettre d&#x27;inspecter tout l&#x27;historique
de votre dépôt, avec des options en veux-tu en voilà pour personnaliser
l&#x27;affichage.

Un &#x60;git log&#x60; basique ça ressemble à ça :

&#x60;&#x60;&#x60; console
$ git log
commit 8120de7b7139e46b9cbc1c3ee89a02962dbc198e
Author: madx &lt;madx+github@yapok.org&gt;
Date:   Mon Nov 4 23:28:11 2013 +0100

    Premier commit
&#x60;&#x60;&#x60;

Oui, c&#x27;est le commit que je viens de faire dans la partie précédente. Comment
j&#x27;en suis sûr ? Car je peux utiliser &#x60;git show&#x60; pour afficher les détails d&#x27;un
objet Git (il n&#x27;y a pas que des commits, mais on verra ça une prochaine fois).

&#x60;git show&#x60; prend en argument le fameux &#x60;SHA1&#x60; du commit :

&#x60;&#x60;&#x60; console
$ git show 8120de7b7139e46b9cbc1c3ee89a02962dbc198e
commit 8120de7b7139e46b9cbc1c3ee89a02962dbc198e
Author: madx &lt;madx+github@yapok.org&gt;
Date:   Mon Nov 4 23:28:11 2013 +0100

    Premier commit

diff --git a/putain_de_hello_world.rb b/putain_de_hello_world.rb
new file mode 100644
index 0000000..ded37dc
--- /dev/null
+++ b/putain_de_hello_world.rb
@@ -0,0 +1 @@
+puts &quot;Hello, putain de codeur !!!&quot;
&#x60;&#x60;&#x60;

Dit comme ça, ça a pas l&#x27;air de casser trois pattes à un canard, mais c&#x27;est la
base de la base de la praticité. Je vous fait pas l&#x27;insulte de vous expliquer le
détails, vous êtes sans doute assez malins pour comprendre ce que git raconte
sur la sortie de ces deux commandes.

Remarquez que &#x60;git show&#x60; affiche en bonus les différences introduites par un
fichier. Ces différences on peut aussi les voir avant de commiter avec &#x60;git
diff&#x60;, ce qui est bien pratique.

Entraînez vous maintenant à faire des commits, à inspecter et à farfouiller les
pages de &#x60;man&#x60;, c&#x27;est la meilleure façon d&#x27;apprendre. Après on va attaquer le
gros morceau, celui qui fait la force de Git.

&lt;figure&gt;
  ![Mind blown]({{happyplan.baseUrls.media}}/memes/mind_blown.gif)
&lt;/figure&gt;

## Branchement et fusions

Créer une branche, ça permet de travailler sur une fonctionnalité ou un bug
précis, sans encombrer la ligne de conduite principale, qui peut évoluer sous
d&#x27;autres contraintes.

Dans Git, les branches sont une partie essentielle de quasiment tout *workflow*,
et leur manipulation est très rapide et très légère.

Pour en revenir à mon histoire de maillon, créer une branche revient à créer un
point à partir duquel deux chaînes vont être possibles.

C&#x27;est aussi simple qu&#x27;un &#x60;git branch le-nom-de-ma-branche&#x60;. Cette commande se
contente de créer la branche, pour se positionner dessus on utilise &#x60;git
checkout&#x60; qui permet de naviguer de branche en branche tel Tarzan sur ses
lianes.

Comme c&#x27;est super chiant à écrire, il existe un raccourci bien pratique : &#x60;git
checkout -b&#x60;, auquel on passe un nom de branche comme pour &#x60;git branch&#x60;.

Une fois qu&#x27;on est bien sur la branche, tous les commits suivants seront liés à
cette branche.

On peut utiliser &#x60;git branch&#x60; sans argument pour lister les branches, celle avec
un petit asterisque devant c&#x27;est la branche courante.

Essayons ça avec notre petit dépôt :

&#x60;&#x60;&#x60; console
$ git branch
* master
prout (master:8120de7) $ git checkout -b add-shebang
Basculement sur la nouvelle branche &#x27;add-shebang&#x27;
$ vi putain_de_hello_world.rb
$ git status
# Sur la branche add-shebang
# Modifications qui ne seront pas validées :
#   (utilisez &quot;git add &lt;fichier&gt;...&quot; pour mettre à jour ce qui sera validé)
#   (utilisez &quot;git checkout -- &lt;fichier&gt;...&quot; pour annuler les modifications dans la copie de travail)
#
#	modifié : putain_de_hello_world.rb
#
aucune modification n&#x27;a été ajoutée au commit (utilisez &quot;git add&quot; ou &quot;git commit -a&quot;)
$ git add putain_de_hello_world.rb
$ git commit
[add-shebang 5d48735] Add shebang
 1 file changed, 1 insertion(+)
$ git log --pretty=oneline --decorate
5d48735fcc805d51e2e294df5d9d22d481250789 (HEAD, add-shebang) Add shebang
8120de7b7139e46b9cbc1c3ee89a02962dbc198e (master) Premier commit
&#x60;&#x60;&#x60;

Comme vous le voyez grâce à l&#x27;option &#x60;--decorate--&#x60; de &#x60;git log&#x60;, on a bien
notre branche qui pointe sur le dernier commit fait, alors que la branche de
base fournie par Git, &#x60;master&#x60;, reste au commit précédent.

Dernière étape avant la fin de cette article : le redouté et redoutable
&#x60;merge&#x60; !

Pour fusionner nos deux branches on va utiliser cette commande en se plaçant sur
la branche dans laquelle on va fusionner et en passant en argument la branche à
fusionner.

Si vous avez bien suivi, on va donc faire les choses suivantes :

&#x60;&#x60;&#x60; console
$ git checkout master
Basculement sur la branche &#x27;master&#x27;
$ git merge add-shebang
Updating 8120de7..5d48735
Fast-forward
 putain_de_hello_world.rb | 1 +
 1 file changed, 1 insertion(+)
&#x60;&#x60;&#x60;

Vous remarquez que Git signale *Fast-forward*. Comme le commit pointé par
&#x60;add-shebang&#x60; est un fils direct de celui de &#x60;master&#x60;, Git se contente de faire
pointer &#x60;master&#x60; sur celui-ci, ce qui est beaucoup plus rapide.

Dans le cas où on a eu des modifications sur &#x60;master&#x60; entre temps, on aurait eu
une vraie fusion des contenus des commits, avec éventuellement une résolution de
conflits, mais on verra ça dans un prochain article !

## La suite

On a vu les bases, et très bientôt on va approfondir le sujet, en voyant
notamment comment collaborer, comment résoudre des conflits ou des problèmes
d&#x27;utilisation de Git, tout ça dans la joie et la bonne humeur.

## Références

Si vous voulez en savoir plus sur Git, la [documentation officielle][git:doc] est plutôt
bien foutue.

Si vous aimez les petites références rapides et illustrées, le [Git
Guide][git-guide] de Roger Dudler est une bonne manière d&#x27;apprendre.

## Hey ! Tu veux appliquer ça pour contribuer à Putain de Code ?

Pas de problème, on a écrit un post exprès :
[Comment contribuer](posts/comment-contribuer/) !

[git:website]: http://git-scm.org/
[git:doc]: http://git-scm.com/documentation
[git-guide]: http://rogerdudler.github.io/git-guide/
[cpold]: http://roland.entierement.nu/blog/2008/01/22/cpold-la-poudre-verte-du-suivi-de-versions.html
[gitx]: http://gitx.frim.nl/
[gitg]: https://wiki.gnome.org/Gitg
{{/markdown}}
</description>
              <pubDate>Wed, 06 November 2013 01:00:00 +0100</pubDate>
              <link>/dist/posts/git/versionner-avec-git/index.html</link>
              <guid isPermaLink="true">/dist/posts/git/versionner-avec-git/index.html</guid>
          </item>

    </channel>
</rss>
